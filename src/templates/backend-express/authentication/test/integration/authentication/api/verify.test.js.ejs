'use strict';

const chai = require('chai');
const chaiHttp = require('chai-http');
const expect = chai.expect;
const server = require('../../../../app');

chai.use(chaiHttp);

const AuthenticationModel = require('../../../../resources/authentication/Authentication');
const AuthenticationService = require('../../../../resources/authentication/AuthenticationService');
const AuthenticationController = require('../../../../resources/authentication/AuthenticationController');

const FAKE_RECORD = {
  authority_id: 1,
  email: 'johnsmith@example.com',
  password: 'testPassword',
};
const FAKE_CREDENTIALS = {
  email: FAKE_RECORD.email,
  password: FAKE_RECORD.password,
};

let jwtToken = null;

describe('TESTING: AuthenticationController.verify server failure', () => {
  it('it should call the next callback with the error', async () => {
    let errorReturn = null;
    await AuthenticationController.verify(null, null, function(error) {
      errorReturn = error;
    });

    expect(errorReturn).to.be.an('error');
  });
});

describe('TESTING: /verify for authentication', () => {
  before(async () => {
    await AuthenticationModel.query().delete();
    await AuthenticationModel.query().insert(FAKE_RECORD);
  });

  beforeEach(async () => {
    jwtToken = await AuthenticationService.authenticate(FAKE_CREDENTIALS);
  });

  after(async () => {
    await AuthenticationModel.query().delete();
  });

  it('it should return an authority object if JWT is valid', (done) => {
    chai
      .request(server)
      .get('/api/v1/authentication/verify')
      .set('content-type', 'application/json')
      .set('Authorization', `Bearer ${jwtToken}`)
      .send(FAKE_CREDENTIALS)
      .end((error, response) => {
        expect(response).to.have.status(200);

        expect(response)
          .to.have.property('body')
          .be.an('object');
        expect(response)
          .to.have.nested.property('body.data')
          .be.an('object');
        expect(response)
          .to.have.nested.property('body.data.authorityId')
          .be.a('number')
          .and.equal(FAKE_RECORD.authority_id);
        expect(response)
          .to.have.nested.property('body.iat')
          .be.a('number');
        expect(response)
          .to.have.nested.property('body.exp')
          .be.a('number');

        done();
      });
  });

  it('it should fail if the JWT token is not valid', (done) => {
    chai
      .request(server)
      .get('/api/v1/authentication/verify')
      .set('content-type', 'application/json')
      .set('Authorization', 'Bearer not_a_real_token')
      .send(FAKE_CREDENTIALS)
      .end((error, response) => {
        expect(response).to.have.status(401);

        expect(response)
          .to.have.property('body')
          .be.an('object');
        expect(response)
          .to.have.nested.property('body.type')
          .equal('InvalidTokenError');
        expect(response)
          .to.have.nested.property('body.error')
          .equal('JsonWebTokenError: jwt malformed');

        done();
      });
  });
});
