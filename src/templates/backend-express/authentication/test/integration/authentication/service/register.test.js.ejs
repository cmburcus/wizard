'use strict';

const chai = require('chai');

const expect = chai.expect;

const AuthenticationModel = require('../../../../resources/authentication/Authentication');
const AuthenticationService = require('../../../../resources/authentication/AuthenticationService');

const FAKE_AUTHORITY_ID = 1;
const FAKE_EMAIL = 'johnsmith@example.com';
const FAKE_PASSWORD = 'testPassword';

const POSTGRESS_UNIQUE_FIELD_VIOLATION_CODE = '23505';

describe('TESTING: AuthenticationService.register', () => {
  beforeEach(async () => {
    await AuthenticationModel.query().delete();
  });

  after(async () => {
    await AuthenticationModel.query().delete();
  });

  it('it should create an authentication record if the data is valid', async () => {
    let result = null;

    const record = {
      authority_id: FAKE_AUTHORITY_ID,
      email: FAKE_EMAIL,
      password: FAKE_PASSWORD,
    };

    try {
      result = await AuthenticationService.register(record);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('object');
    expect(result)
      .to.have.property('authority_id')
      .equal(record.authority_id);
    expect(result)
      .to.have.property('email')
      .equal(record.email);
    expect(result)
      .to.have.property('password')
      .not.equal(record.password);
    expect(result)
      .to.have.property('created_at')
      .be.a('string');
    expect(result)
      .to.have.property('updated_at')
      .be.a('string');
  });

  it('it should fail if no data is provided', async () => {
    let result = null;

    try {
      result = await AuthenticationService.register();
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('type')
      .equal('InvalidArgumentError');
    expect(result)
      .to.have.property('status')
      .equal(400);
    expect(result)
      .to.have.property('error')
      .equal('register');
  });

  // AUTHORITY ID : SPECIFIC

  it('it should create an authentication record if authority_id is null', async () => {
    let result = null;

    const record = {
      authority_id: null,
      email: FAKE_EMAIL,
      password: FAKE_PASSWORD,
    };

    try {
      result = await AuthenticationService.register(record);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('object');
    expect(result)
      .to.have.property('authority_id')
      .equal(record.authority_id);
    expect(result)
      .to.have.property('email')
      .equal(record.email);
    expect(result)
      .to.have.property('password')
      .not.equal(record.password);
    expect(result)
      .to.have.property('created_at')
      .be.a('string');
    expect(result)
      .to.have.property('updated_at')
      .be.a('string');
  });

  it('it should fail if authority_id is not a number', async () => {
    let result = null;

    const record = {
      authority_id: '1',
      email: FAKE_EMAIL,
      password: FAKE_PASSWORD,
    };

    try {
      result = await AuthenticationService.register(record);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('name')
      .equal('ValidationError');
    expect(result)
      .to.have.property('type')
      .equal('ModelValidation');
    expect(result)
      .to.have.property('statusCode')
      .equal(400);
    expect(result)
      .to.have.property('data')
      .be.an('object');
    expect(result)
      .to.have.nested.property('data.authority_id')
      .be.an('array');
  });

  it('it should fail if authority_id is a negative number', async () => {
    let result = null;

    const record = {
      authority_id: -1,
      email: FAKE_EMAIL,
      password: FAKE_PASSWORD,
    };

    try {
      result = await AuthenticationService.register(record);
    } catch (error) {
      result = error;
    }
    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('type')
      .equal('InvalidArgumentError');
    expect(result)
      .to.have.property('status')
      .equal(400);
    expect(result)
      .to.have.property('error')
      .equal('register');
  });

  it('it should fail if authority_id is not unique', async () => {
    let result = null;

    const recordOne = {
      authority_id: FAKE_AUTHORITY_ID,
      email: FAKE_EMAIL,
      password: FAKE_PASSWORD,
    };
    const recordTwo = {
      authority_id: FAKE_AUTHORITY_ID,
      email: `2${FAKE_EMAIL}`,
      password: FAKE_PASSWORD,
    };

    try {
      await AuthenticationModel.query().insert(recordOne);

      result = await AuthenticationService.register(recordTwo);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('name')
      .equal('error');
    expect(result)
      .to.have.property('code')
      .equal(POSTGRESS_UNIQUE_FIELD_VIOLATION_CODE);
    expect(result)
      .to.have.property('constraint')
      .equal('authentications_authority_id_unique');
  });

  // EMAIL : SPECIFIC

  it('it should fail if email is null', async () => {
    let result = null;

    const record = {
      authority_id: FAKE_AUTHORITY_ID,
      email: null,
      password: FAKE_PASSWORD,
    };

    try {
      result = await AuthenticationService.register(record);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('type')
      .equal('InvalidArgumentError');
    expect(result)
      .to.have.property('status')
      .equal(400);
    expect(result)
      .to.have.property('error')
      .equal('register');
  });

  it('it should fail if email is not a string', async () => {
    let result = null;

    const record = {
      authority_id: FAKE_AUTHORITY_ID,
      email: 12345,
      password: FAKE_PASSWORD,
    };

    try {
      result = await AuthenticationService.register(record);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('name')
      .equal('ValidationError');
    expect(result)
      .to.have.property('type')
      .equal('ModelValidation');
    expect(result)
      .to.have.property('statusCode')
      .equal(400);
    expect(result)
      .to.have.property('data')
      .be.an('object');
    expect(result)
      .to.have.nested.property('data.email')
      .be.an('array');
  });

  it('it should fail if email is longer than 250 characters', async () => {
    let result = null;

    const record = {
      authority_id: FAKE_AUTHORITY_ID,
      email:
        'abcdefghijklmnopqrstuvwzabcdefghijklmnopqrstuvwzababcdefghijklmnopqrstuvwzabcdefghijklmnopqrstuvwzababcdefghijklmnopqrstuvwzabcdefghijklmnopqrstuvwzababcdefghijklmnopqrstuvwzabcdefghijklmnopqrstuvwzababcdefghijklmnopqrstuvwzabcdefghijklmnopqrstu@w.com',
      password: FAKE_PASSWORD,
    };

    try {
      result = await AuthenticationService.register(record);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('name')
      .equal('ValidationError');
    expect(result)
      .to.have.property('type')
      .equal('ModelValidation');
    expect(result)
      .to.have.property('statusCode')
      .equal(400);
    expect(result)
      .to.have.property('data')
      .be.an('object');
    expect(result)
      .to.have.nested.property('data.email')
      .be.an('array');
  });

  it('it should fail if email is not unique', async () => {
    let result = null;

    const recordOne = {
      authority_id: FAKE_AUTHORITY_ID,
      email: FAKE_EMAIL,
      password: FAKE_PASSWORD,
    };
    const recordTwo = {
      authority_id: FAKE_AUTHORITY_ID + 1,
      email: FAKE_EMAIL,
      password: FAKE_PASSWORD,
    };

    try {
      await AuthenticationModel.query().insert(recordOne);

      result = await AuthenticationService.register(recordTwo);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('name')
      .equal('error');
    expect(result)
      .to.have.property('code')
      .equal(POSTGRESS_UNIQUE_FIELD_VIOLATION_CODE);
    expect(result)
      .to.have.property('constraint')
      .equal('authentications_email_unique');
  });

  // PASSWORD : SPECIFIC

  it('it should fail if password is null', async () => {
    let result = null;

    const record = {
      authority_id: FAKE_AUTHORITY_ID,
      email: FAKE_EMAIL,
      password: null,
    };

    try {
      result = await AuthenticationService.register(record);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('type')
      .equal('InvalidArgumentError');
    expect(result)
      .to.have.property('status')
      .equal(400);
    expect(result)
      .to.have.property('error')
      .equal('register');
  });

  it('it should fail if password is not a string', async () => {
    let result = null;

    const record = {
      authority_id: FAKE_AUTHORITY_ID,
      email: FAKE_EMAIL,
      password: 123,
    };

    try {
      result = await AuthenticationService.register(record);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('name')
      .equal('ValidationError');
    expect(result)
      .to.have.property('type')
      .equal('ModelValidation');
    expect(result)
      .to.have.property('statusCode')
      .equal(400);
    expect(result)
      .to.have.nested.property('data.password')
      .be.an('array');
  });
});
