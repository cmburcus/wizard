'use strict';

const chai = require('chai');

const expect = chai.expect;

const AuthenticationModel = require('../../../../resources/authentication/Authentication');
const AuthenticationService = require('../../../../resources/authentication/AuthenticationService');

const FAKE_RECORD = {
  authority_id: 1,
  email: 'johnsmith@example.com',
  password: 'testPassword',
};
const FAKE_CREDENTIALS = {
  email: FAKE_RECORD.email,
  password: FAKE_RECORD.password,
};

let token = null;

describe('TESTING: AuthenticationService.verify', () => {
  before(async () => {
    await AuthenticationModel.query().delete();
    await AuthenticationService.register(FAKE_RECORD);
  });

  beforeEach(async () => {
    token = await AuthenticationService.authenticate(FAKE_CREDENTIALS);
  });

  after(async () => {
    await AuthenticationModel.query().delete();
  });

  it('it should return an authority object if JWT is valid', async () => {
    let result = null;

    try {
      result = await AuthenticationService.verify(token);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('object');
    expect(result)
      .to.have.property('data')
      .be.an('object');
    expect(result)
      .to.have.nested.property('data.authorityId')
      .be.a('number')
      .and.equal(FAKE_RECORD.authority_id);
    expect(result)
      .to.have.property('iat')
      .be.a('number');
    expect(result)
      .to.have.property('exp')
      .be.a('number');
  });

  it('it should fail if the JWT token is not valid', async () => {
    let result = null;

    try {
      result = await AuthenticationService.verify('SomeWrongToken');
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('type')
      .equal('InvalidTokenError');
    expect(result)
      .to.have.property('status')
      .equal(401);
    expect(result)
      .to.have.property('error')
      .equal('JsonWebTokenError: jwt malformed');
  });

  it('it should fail if the JWT token is not provided', async () => {
    let result = null;

    try {
      result = await AuthenticationService.verify();
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('type')
      .equal('InvalidArgumentError');
    expect(result)
      .to.have.property('status')
      .equal(400);
    expect(result)
      .to.have.property('error')
      .equal('verify');
  });
});
