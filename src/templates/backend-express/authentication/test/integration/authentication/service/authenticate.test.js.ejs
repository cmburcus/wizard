'use strict';

const chai = require('chai');

const expect = chai.expect;

const AuthenticationModel = require('../../../../resources/authentication/Authentication');
const AuthenticationService = require('../../../../resources/authentication/AuthenticationService');

const jsonwebtoken = require('jsonwebtoken');

const FAKE_RECORD = {
  authority_id: 1,
  email: 'johnsmith@example.com',
  password: 'testPassword',
};
const FAKE_CREDENTIALS = {
  email: FAKE_RECORD.email,
  password: FAKE_RECORD.password,
};

describe('TESTING: AuthenticationService.authenticate', () => {
  before(async () => {
    await AuthenticationModel.query().delete();
    await AuthenticationService.register(FAKE_RECORD);
  });

  after(async () => {
    await AuthenticationModel.query().delete();
  });

  it('it should authenticate if the credentials are valid', async () => {
    let result = null;

    try {
      result = await AuthenticationService.authenticate(FAKE_CREDENTIALS);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.a('string');
  });

  it('it should authenticate if even if the email is wrong case', async () => {
    let result = null;

    const credentials = {
      email: FAKE_CREDENTIALS.email.toUpperCase(),
      password: FAKE_CREDENTIALS.password,
    };

    try {
      result = await AuthenticationService.authenticate(credentials);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.a('string');
  });

  it('it should return a valid JWT token', async () => {
    let result = null;

    try {
      result = await AuthenticationService.authenticate(FAKE_CREDENTIALS);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.a('string');

    let verifiedToken = null;

    try {
      verifiedToken = await jsonwebtoken.verify(result, process.env.JWT_SECRET);
    } catch (error) {
      verifiedToken = error;
    }

    expect(verifiedToken).to.be.an('object');
    expect(verifiedToken)
      .to.have.property('data')
      .be.an('object');
    expect(verifiedToken)
      .to.have.nested.property('data.authorityId')
      .be.a('number')
      .and.equal(FAKE_RECORD.authority_id);
    expect(verifiedToken)
      .to.have.property('iat')
      .be.a('number');
    expect(verifiedToken)
      .to.have.property('exp')
      .be.a('number');
  });

  it('it should set a token expiration even if one is not set in the environment variables', async () => {
    const currentJwtExpiration = process.env.JWT_EXPIRES_IN;

    process.env.JWT_EXPIRES_IN = '';

    let result = null;

    try {
      result = await AuthenticationService.authenticate(FAKE_CREDENTIALS);
    } catch (error) {
      result = error;
    }

    // Setting the JWT back so it does not impact other tests
    process.env.JWT_EXPIRES_IN = currentJwtExpiration;

    expect(result).to.be.a('string');

    let verifiedToken = null;

    try {
      verifiedToken = await jsonwebtoken.verify(result, process.env.JWT_SECRET);
    } catch (error) {
      verifiedToken = error;
    }

    expect(verifiedToken).to.be.an('object');
    expect(verifiedToken)
      .to.have.property('data')
      .be.an('object');
    expect(verifiedToken)
      .to.have.nested.property('data.authorityId')
      .be.a('number')
      .and.equal(FAKE_RECORD.authority_id);
    expect(verifiedToken)
      .to.have.property('iat')
      .be.a('number');
    expect(verifiedToken)
      .to.have.property('exp')
      .be.a('number');
  });

  it('it should fail if no data is provided', async () => {
    let result = null;

    try {
      result = await AuthenticationService.authenticate();
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('type')
      .equal('InvalidArgumentError');
    expect(result)
      .to.have.property('status')
      .equal(400);
    expect(result)
      .to.have.property('error')
      .equal('authenticate');
  });

  it('it should fail if email is not found', async () => {
    let result = null;

    const credentials = {
      email: 'wrongemail@example.com',
      password: FAKE_CREDENTIALS.password,
    };

    try {
      result = await AuthenticationService.authenticate(credentials);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('type')
      .equal('AuthenticationError');
    expect(result)
      .to.have.property('status')
      .equal(401);
    expect(result)
      .to.have.property('error')
      .equal('no entry found');
  });

  it('it should fail if password is not correct', async () => {
    let result = null;

    const credentials = {
      email: FAKE_CREDENTIALS.email,
      password: 'wrongPassword',
    };

    try {
      result = await AuthenticationService.authenticate(credentials);
    } catch (error) {
      result = error;
    }

    expect(result).to.be.an('error');
    expect(result)
      .to.have.property('type')
      .equal('AuthenticationError');
    expect(result)
      .to.have.property('status')
      .equal(401);
    expect(result)
      .to.have.property('error')
      .equal('invalid password');
  });
});
