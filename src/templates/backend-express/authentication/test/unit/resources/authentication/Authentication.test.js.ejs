'use strict';

const chai = require('chai');

const expect = chai.expect;
const AuthenticationModel = require('../../../../resources/authentication/Authentication');

const bcrypt = require('bcrypt');

const FAKE_RECORD = {
  authority_id: 1,
  email: 'test@example.com',
  password: 'testPassword',
};

describe('TESTING: Authentication Model', () => {
  it('it should encrypt the password before inserting', async () => {
    const model = await AuthenticationModel.fromJson(FAKE_RECORD);

    model.$beforeInsert();

    expect(model)
      .to.have.property('password')
      .not.equal(FAKE_RECORD.password);
    expect(bcrypt.compareSync(FAKE_RECORD.password, model.password)).to.equal(true);
  });

  it('it should encrypt the password before updating if it exists', async () => {
    const model = await AuthenticationModel.fromJson(FAKE_RECORD);

    model.$beforeUpdate();

    expect(model)
      .to.have.property('password')
      .not.equal(FAKE_RECORD.password);
    expect(bcrypt.compareSync(FAKE_RECORD.password, model.password)).to.equal(true);
  });

  it('it should ignore the password encryption before updating if it does not exist', async () => {
    const model = await AuthenticationModel.fromJson(FAKE_RECORD);

    delete model.password;

    model.$beforeUpdate();

    expect(model).to.not.have.property('password');
  });

  it('it should not return the password when formatting as json', async () => {
    const model = await AuthenticationModel.fromJson(FAKE_RECORD);

    expect(model.toJSON()).to.not.have.property('password');
  });
});
