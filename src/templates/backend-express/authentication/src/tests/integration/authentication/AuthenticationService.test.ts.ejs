'use strict';

import chai from 'chai';
import jsonwebtoken from 'jsonwebtoken';

import AuthenticationModel from '../../../resources/authentication/Authentication';
import AuthenticationService from '../../../resources/authentication/AuthenticationService';

const expect = chai.expect;

const POSTGRESS_UNIQUE_FIELD_VIOLATION_CODE: string = '23505';

// Fake data to be used for the tests
interface FakeRecord {
  id?: any
  authority_id?: any
  email: any
  password: any
}

const FAKE_RECORDS: FakeRecord[] = [
  {
    authority_id: 1,
    email: 'test@example.com',
    password: 'asdfasdf',
  },
  {
    authority_id: null,
    email: 'test2@example.com',
    password: 'asdfasdf',
  },
];

const FAKE_CREDENTIALS: FakeRecord = {
  email: FAKE_RECORDS[0].email,
  password: FAKE_RECORDS[0].password,
};

const FAKE_AUTHORITY_ID: any = 1;
const FAKE_EMAIL: any = 'johnsmith@example.com';
const FAKE_PASSWORD: any = 'testPassword';

let recordId: any = null;
let storedRecord: FakeRecord = null;
let token: string = null;

describe('TESTING: AuthenticationService', () => {
  beforeEach(async () => {
    await AuthenticationModel.query().delete();
    recordId = null;
    storedRecord = null;
    token = null;
  });

  after(async () => {
    await AuthenticationModel.query().delete();
  });

  describe('query', () => {
    beforeEach(async () => {
      await AuthenticationModel.query().insert(FAKE_RECORDS);
    });

    it('it should get an empty array if there are no records', async () => {
      await AuthenticationModel.query().delete();

      let result = null;

      try {
        result = await AuthenticationService.query();
      } catch (error) {
        result = error;
      }

      expect(result)
        .to.be.an('array')
        .and.have.lengthOf(0);
    });

    it('it should get all records in the database', async () => {
      let result = null;

      try {
        result = await AuthenticationService.query();
      } catch (error) {
        result = error;
      }

      expect(result)
        .to.be.an('array')
        .and.have.lengthOf(2);
    });
  });

  describe('show', () => {
    beforeEach(async () => {
      const records = await AuthenticationModel.query().insert(FAKE_RECORDS);
      recordId = records[0].id;
    });

    it('it should get record if found in the database', async () => {
      let result = null;

      try {
        result = await AuthenticationService.show(recordId);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('id')
        .be.a('number');
      expect(result)
        .to.have.property('authority_id')
        .be.a('number');
      expect(result)
        .to.have.property('email')
        .be.a('string');
      expect(result)
        .to.have.property('password')
        .be.a('string');
      expect(result)
        .to.have.property('created_at')
        .be.a('date');
      expect(result)
        .to.have.property('updated_at')
        .be.a('date');
    });

    it('it should return undefined if a record does not exist', async () => {
      let result = null;

      try {
        result = await AuthenticationService.show(9999999);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.undefined;
    });

    it('it should fail if id is not defined', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = await AuthenticationService.show();
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('show');
    });
  });

  describe('create', () => {
    it('it should create a record if the data is valid', async () => {
      const record = {
        authority_id: FAKE_AUTHORITY_ID,
        email: FAKE_EMAIL,
        password: FAKE_PASSWORD,
      };

      let result = null;

      try {
        result = await AuthenticationService.create(record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('authority_id')
        .equal(record.authority_id);
      expect(result)
        .to.have.property('email')
        .equal(record.email);
      expect(result)
        .to.have.property('password')
        .not.equal(record.password);
      expect(result)
        .to.have.property('id')
        .be.a('number');
      expect(result)
        .to.have.property('created_at')
        .be.a('string');
      expect(result)
        .to.have.property('updated_at')
        .be.a('string');
    });

    it('it should fail if required fields are not defined', async () => {
      let result = null;

      try {
        result = await AuthenticationService.create({});
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('name')
        .equal('ValidationError');
      expect(result)
        .to.have.property('type')
        .equal('ModelValidation');
      expect(result)
        .to.have.property('statusCode')
        .equal(400);
      expect(result).to.have.property('name');
      expect(result).to.have.property('type');
      expect(result).to.have.property('statusCode');
    });

    it('it should fail if no data is provided', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = await AuthenticationService.create();
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('create');
    });
  });

  describe('update', () => {
    beforeEach(async () => {
      const records = await AuthenticationModel.query().insert(FAKE_RECORDS);
      storedRecord = <FakeRecord> records[0];
    });

    it('it should update the record if the data is valid', async () => {
      const record = {
        authority_id: 2,
        email: 'newtest@example.com',
        password: 'asdfasdf2',
      };

      let result = null;

      try {
        result = await AuthenticationService.update(storedRecord.id, record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('authority_id')
        .equal(record.authority_id);
      expect(result)
        .to.have.property('email')
        .equal(record.email);
      expect(result)
        .to.have.property('password')
        .not.equal(record.password);
      expect(result)
        .to.have.property('id')
        .be.a('number');
      expect(result)
        .to.have.property('created_at')
        .be.a('date');
      expect(result)
        .to.have.property('updated_at')
        .be.a('date');
    });

    it('it should fail if required fields are not defined', async () => {
      let result = null;

      try {
        result = await AuthenticationService.update(storedRecord.id, {});
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('name')
        .equal('ValidationError');
      expect(result)
        .to.have.property('type')
        .equal('ModelValidation');
      expect(result)
        .to.have.property('statusCode')
        .equal(400);
      expect(result).to.have.property('name');
      expect(result).to.have.property('type');
      expect(result).to.have.property('statusCode');
    });

    it('it should fail if no data is provided', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = await AuthenticationService.update(storedRecord.id);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('update');
    });
  });

  describe('patch', () => {
    beforeEach(async () => {
      const records = await AuthenticationModel.query().insert(FAKE_RECORDS);
      storedRecord = <FakeRecord> records[0];
    });

    it('it should update the record if the data is valid', async () => {
      const record = {
        email: 'newtest@example.com',
      };

      let result = null;

      try {
        result = await AuthenticationService.patch(storedRecord.id, record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('authority_id')
        .equal(storedRecord.authority_id);
      expect(result)
        .to.have.property('email')
        .equal(record.email);
      expect(result)
        .to.have.property('password')
        .equal(storedRecord.password);
      expect(result)
        .to.have.property('id')
        .be.a('number');
      expect(result)
        .to.have.property('created_at')
        .be.a('date');
      expect(result)
        .to.have.property('updated_at')
        .be.a('date');
    });

    it('it should fail if no data is provided', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = await AuthenticationService.patch(storedRecord.id);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('patch');
    });
  });

  describe('delete', () => {
    beforeEach(async () => {
      const records = await AuthenticationModel.query().insert(FAKE_RECORDS);
      recordId = records[0].id;
    });

    it('it should delete record if it exists', async () => {
      let result = null;

      try {
        result = await AuthenticationService.delete(recordId);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.a('number');
      expect(result).to.equal(1);
    });

    it('it should return 0 if the record does not exist', async () => {
      let result = null;

      try {
        result = await AuthenticationService.delete(9999999);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.a('number');
      expect(result).to.equal(0);
    });

    it('it should fail if id is not defined', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = await AuthenticationService.delete();
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('delete');
    });
  });

  describe('countBy', () => {
    beforeEach(async () => {
      const records = await AuthenticationModel.query().insert(FAKE_RECORDS);
      recordId = records[0].id;
    });

    it('it should be able to perform a count operation', async () => {
      let result = null;

      try {
        result = await AuthenticationService.countBy([{ key: 'email', value: 'test@example.com' }]);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('array');
      expect(result[0])
        .to.have.property('count')
        .be.equal('1');
    });

    it('it should be able to perform a count operation excluding an id', async () => {
      let result = null;

      try {
        result = await AuthenticationService.countBy([
          {
            key: 'email',
            value: 'test@example.com',
          },
          {
            key: 'id',
            value: recordId,
            condition: '!=',
          },
        ]);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('array');
      expect(result[0])
        .to.have.property('count')
        .be.equal('0');
    });
  });

  describe('register', () => {
    it('it should create an authentication record if the data is valid', async () => {
      let result = null;

      const record: FakeRecord = {
        authority_id: FAKE_AUTHORITY_ID,
        email: FAKE_EMAIL,
        password: FAKE_PASSWORD,
      };

      try {
        // @ts-ignore
        result = await AuthenticationService.register(record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('authority_id')
        .equal(record.authority_id);
      expect(result)
        .to.have.property('email')
        .equal(record.email);
      expect(result)
        .to.have.property('password')
        .not.equal(record.password);
      expect(result)
        .to.have.property('created_at')
        .be.a('string');
      expect(result)
        .to.have.property('updated_at')
        .be.a('string');
    });

    it('it should fail if no data is provided', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = await AuthenticationService.register();
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('register');
    });

    // AUTHORITY ID : SPECIFIC

    it('it should create an authentication record if authority_id is null', async () => {
      let result = null;

      const record: FakeRecord = {
        authority_id: null,
        email: FAKE_EMAIL,
        password: FAKE_PASSWORD,
      };

      try {
        // @ts-ignore
        result = await AuthenticationService.register(record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('authority_id')
        .equal(record.authority_id);
      expect(result)
        .to.have.property('email')
        .equal(record.email);
      expect(result)
        .to.have.property('password')
        .not.equal(record.password);
      expect(result)
        .to.have.property('created_at')
        .be.a('string');
      expect(result)
        .to.have.property('updated_at')
        .be.a('string');
    });

    it('it should fail if authority_id is not a number', async () => {
      let result = null;

      const record: FakeRecord = {
        authority_id: '1',
        email: FAKE_EMAIL,
        password: FAKE_PASSWORD,
      };

      try {
        // @ts-ignore
        result = await AuthenticationService.register(record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('name')
        .equal('ValidationError');
      expect(result)
        .to.have.property('type')
        .equal('ModelValidation');
      expect(result)
        .to.have.property('statusCode')
        .equal(400);
      expect(result)
        .to.have.property('data')
        .be.an('object');
      expect(result)
        .to.have.nested.property('data.authority_id')
        .be.an('array');
    });

    it('it should fail if authority_id is a negative number', async () => {
      let result = null;

      const record: FakeRecord = {
        authority_id: -1,
        email: FAKE_EMAIL,
        password: FAKE_PASSWORD,
      };

      try {
        // @ts-ignore
        result = await AuthenticationService.register(record);
      } catch (error) {
        result = error;
      }
      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('register');
    });

    it('it should fail if authority_id is not unique', async () => {
      let result = null;

      const recordOne: FakeRecord = {
        authority_id: FAKE_AUTHORITY_ID,
        email: FAKE_EMAIL,
        password: FAKE_PASSWORD,
      };
      const recordTwo: FakeRecord = {
        authority_id: FAKE_AUTHORITY_ID,
        email: `2${FAKE_EMAIL}`,
        password: FAKE_PASSWORD,
      };

      try {
        await AuthenticationModel.query().insert(recordOne);

        // @ts-ignore
        result = await AuthenticationService.register(recordTwo);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('name')
        .equal('error');
      expect(result)
        .to.have.property('code')
        .equal(POSTGRESS_UNIQUE_FIELD_VIOLATION_CODE);
      expect(result)
        .to.have.property('constraint')
        .equal('authentications_authority_id_unique');
    });

    // EMAIL : SPECIFIC

    it('it should fail if email is null', async () => {
      let result = null;

      const record: FakeRecord = {
        authority_id: FAKE_AUTHORITY_ID,
        email: null,
        password: FAKE_PASSWORD,
      };

      try {
        // @ts-ignore
        result = await AuthenticationService.register(record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('register');
    });

    it('it should fail if email is not a string', async () => {
      let result = null;

      const record = {
        authority_id: FAKE_AUTHORITY_ID,
        email: 12345,
        password: FAKE_PASSWORD,
      };

      try {
        // @ts-ignore
        result = await AuthenticationService.register(record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('name')
        .equal('ValidationError');
      expect(result)
        .to.have.property('type')
        .equal('ModelValidation');
      expect(result)
        .to.have.property('statusCode')
        .equal(400);
      expect(result)
        .to.have.property('data')
        .be.an('object');
      expect(result)
        .to.have.nested.property('data.email')
        .be.an('array');
    });

    it('it should fail if email is longer than 250 characters', async () => {
      let result = null;

      const record = {
        authority_id: FAKE_AUTHORITY_ID,
        email:
          'abcdefghijklmnopqrstuvwzabcdefghijklmnopqrstuvwzababcdefghijklmnopqrstuvwzabcdefghijklmnopqrstuvwzababcdefghijklmnopqrstuvwzabcdefghijklmnopqrstuvwzababcdefghijklmnopqrstuvwzabcdefghijklmnopqrstuvwzababcdefghijklmnopqrstuvwzabcdefghijklmnopqrstu@w.com',
        password: FAKE_PASSWORD,
      };

      try {
        // @ts-ignore
        result = await AuthenticationService.register(record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('name')
        .equal('ValidationError');
      expect(result)
        .to.have.property('type')
        .equal('ModelValidation');
      expect(result)
        .to.have.property('statusCode')
        .equal(400);
      expect(result)
        .to.have.property('data')
        .be.an('object');
      expect(result)
        .to.have.nested.property('data.email')
        .be.an('array');
    });

    it('it should fail if email is not unique', async () => {
      let result = null;

      const recordOne: FakeRecord = {
        authority_id: FAKE_AUTHORITY_ID,
        email: FAKE_EMAIL,
        password: FAKE_PASSWORD,
      };
      const recordTwo: FakeRecord = {
        authority_id: FAKE_AUTHORITY_ID + 1,
        email: FAKE_EMAIL,
        password: FAKE_PASSWORD,
      };

      try {
        await AuthenticationModel.query().insert(recordOne);

        // @ts-ignore
        result = await AuthenticationService.register(recordTwo);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('name')
        .equal('error');
      expect(result)
        .to.have.property('code')
        .equal(POSTGRESS_UNIQUE_FIELD_VIOLATION_CODE);
      expect(result)
        .to.have.property('constraint')
        .equal('authentications_email_unique');
    });

    // PASSWORD : SPECIFIC

    it('it should fail if password is null', async () => {
      let result = null;

      const record: FakeRecord = {
        authority_id: FAKE_AUTHORITY_ID,
        email: FAKE_EMAIL,
        password: null,
      };

      try {
        // @ts-ignore
        result = await AuthenticationService.register(record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('register');
    });

    it('it should fail if password is not a string', async () => {
      let result = null;

      const record = {
        authority_id: FAKE_AUTHORITY_ID,
        email: FAKE_EMAIL,
        password: 123,
      };

      try {
        // @ts-ignore
        result = await AuthenticationService.register(record);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('name')
        .equal('ValidationError');
      expect(result)
        .to.have.property('type')
        .equal('ModelValidation');
      expect(result)
        .to.have.property('statusCode')
        .equal(400);
      expect(result)
        .to.have.nested.property('data.password')
        .be.an('array');
    });
  });

  describe('authenticate', () => {
    beforeEach(async () => {
      const records = await AuthenticationModel.query().insert(FAKE_RECORDS);
      storedRecord = <FakeRecord> records[0];
    });

    it('it should authenticate if the credentials are valid', async () => {
      let result = null;

      try {
        result = await AuthenticationService.authenticate(FAKE_CREDENTIALS);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.a('string');
    });

    it('it should authenticate if even if the email is wrong case', async () => {
      let result = null;

      const credentials = {
        email: FAKE_CREDENTIALS.email.toUpperCase(),
        password: FAKE_CREDENTIALS.password,
      };

      try {
        result = await AuthenticationService.authenticate(credentials);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.a('string');
    });

    it('it should return a valid JWT token', async () => {
      let result = null;

      try {
        result = await AuthenticationService.authenticate(FAKE_CREDENTIALS);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.a('string');

      let verifiedToken = null;

      try {
        verifiedToken = await jsonwebtoken.verify(result, process.env.JWT_SECRET);
      } catch (error) {
        verifiedToken = error;
      }

      expect(verifiedToken).to.be.an('object');
      expect(verifiedToken)
        .to.have.property('data')
        .be.an('object');
      expect(verifiedToken)
        .to.have.nested.property('data.authorityId')
        .be.a('number')
        .and.equal(storedRecord.authority_id);
      expect(verifiedToken)
        .to.have.property('iat')
        .be.a('number');
      expect(verifiedToken)
        .to.have.property('exp')
        .be.a('number');
    });

    it('it should set a token expiration even if one is not set in the environment variables', async () => {
      const currentJwtExpiration = process.env.JWT_EXPIRES_IN;

      process.env.JWT_EXPIRES_IN = '';

      let result = null;

      try {
        result = await AuthenticationService.authenticate(FAKE_CREDENTIALS);
      } catch (error) {
        result = error;
      }

      // Setting the JWT back so it does not impact other tests
      process.env.JWT_EXPIRES_IN = currentJwtExpiration;

      expect(result).to.be.a('string');

      let verifiedToken = null;

      try {
        verifiedToken = await jsonwebtoken.verify(result, process.env.JWT_SECRET);
      } catch (error) {
        verifiedToken = error;
      }

      expect(verifiedToken).to.be.an('object');
      expect(verifiedToken)
        .to.have.property('data')
        .be.an('object');
      expect(verifiedToken)
        .to.have.nested.property('data.authorityId')
        .be.a('number')
        .and.equal(storedRecord.authority_id);
      expect(verifiedToken)
        .to.have.property('iat')
        .be.a('number');
      expect(verifiedToken)
        .to.have.property('exp')
        .be.a('number');
    });

    it('it should fail if no data is provided', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = await AuthenticationService.authenticate();
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('authenticate');
    });

    it('it should fail if email is not found', async () => {
      let result = null;

      const credentials = {
        email: 'wrongemail@example.com',
        password: FAKE_CREDENTIALS.password,
      };

      try {
        result = await AuthenticationService.authenticate(credentials);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('AuthenticationError');
      expect(result)
        .to.have.property('status')
        .equal(401);
      expect(result)
        .to.have.property('error')
        .equal('no entry found');
    });

    it('it should fail if password is not correct', async () => {
      let result = null;

      const credentials = {
        email: FAKE_CREDENTIALS.email,
        password: 'wrongPassword',
      };

      try {
        result = await AuthenticationService.authenticate(credentials);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('AuthenticationError');
      expect(result)
        .to.have.property('status')
        .equal(401);
      expect(result)
        .to.have.property('error')
        .equal('invalid password');
    });
  });

  describe('verify', () => {
    beforeEach(async () => {
      const records = await AuthenticationModel.query().insert(FAKE_RECORDS);
      storedRecord = <FakeRecord> records[0];
      token = await AuthenticationService.authenticate(FAKE_CREDENTIALS);
    });

    it('it should return an authority object if JWT is valid', async () => {
      let result = null;

      try {
        result = await AuthenticationService.verify(token);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('data')
        .be.an('object');
      expect(result)
        .to.have.nested.property('data.authorityId')
        .be.a('number')
        .and.equal(storedRecord.authority_id);
      expect(result)
        .to.have.property('iat')
        .be.a('number');
      expect(result)
        .to.have.property('exp')
        .be.a('number');
    });

    it('it should fail if the JWT token is not valid', async () => {
      let result = null;

      try {
        result = await AuthenticationService.verify('SomeWrongToken');
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidTokenError');
      expect(result)
        .to.have.property('status')
        .equal(401);
      expect(result)
        .to.have.property('error')
        .equal('JsonWebTokenError: jwt malformed');
    });

    it('it should fail if the JWT token is not provided', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = await AuthenticationService.verify();
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('verify');
    });
  });

  describe('deleteByAuthorityId', () => {
    beforeEach(async () => {
      const records = await AuthenticationModel.query().insert(FAKE_RECORDS);
      recordId = records[0].authority_id;
    });

    it('it should delete record if it exists', async () => {
      let result = null;

      try {
        result = await AuthenticationService.deleteByAuthorityId(recordId);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.a('number');
      expect(result).to.equal(1);
    });

    it('it should return 0 if the record does not exist', async () => {
      let result = null;

      try {
        result = await AuthenticationService.deleteByAuthorityId(9999999);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.a('number');
      expect(result).to.equal(0);
    });

    it('it should fail if id is not defined', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = await AuthenticationService.deleteByAuthorityId();
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('delete');
    });
  });
});
