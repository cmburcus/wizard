'use strict';

import chai from 'chai';
import bcrypt from 'bcrypt';

import AuthenticationModel from '../../../../resources/authentication/Authentication';

const FAKE_RECORD = {
  authority_id: 1, // eslint-disable-line @typescript-eslint/camelcase
  email: 'test@example.com',
  password: 'testPassword',
};

const expect = chai.expect;

describe('TESTING: Authentication Model', () => {
  it('it should encrypt the password before inserting', async () => {
    const model = await AuthenticationModel.fromJson(FAKE_RECORD);

    model.$beforeInsert();

    expect(model)
      .to.have.property('password')
      .be.a('string')
      .and.not.equal(FAKE_RECORD.password);
    expect(bcrypt.compareSync(FAKE_RECORD.password, model.password as string)).to.equal(true);
  });

  it('it should encrypt the password before updating if it exists', async () => {
    const model = await AuthenticationModel.fromJson(FAKE_RECORD);

    model.$beforeUpdate();

    expect(model)
      .to.have.property('password')
      .be.a('string')
      .and.not.equal(FAKE_RECORD.password);
    expect(bcrypt.compareSync(FAKE_RECORD.password, model.password as string)).to.equal(true);
  });

  it('it should ignore the password encryption before updating if it does not exist', async () => {
    const model = await AuthenticationModel.fromJson(FAKE_RECORD);

    delete model.password;

    model.$beforeUpdate();

    expect(model).to.not.have.property('password');
  });

  it('it should not return the password when formatting as json', async () => {
    const model = await AuthenticationModel.fromJson(FAKE_RECORD);

    expect(model.toJSON()).to.not.have.property('password');
  });
});
