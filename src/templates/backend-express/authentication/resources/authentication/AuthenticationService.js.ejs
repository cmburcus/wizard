'use strict';

const Service = require('../Service');
const AuthenticationModel = require('./Authentication');

const errorUtil = require('error-util');

const raw = require('objection').raw;

const bcrypt = require('bcrypt');
const jsonwebtoken = require('jsonwebtoken');

module.exports = {
  ...Service(AuthenticationModel),

  /**
   * Registers a new password for an email
   *
   * @param {object} record
   */
  register: (record) => {
    if (
      !record ||
      (typeof record.authority_id !== 'undefined' &&
        record.authority_id !== null &&
        record.authority_id <= 0) ||
      !record.email ||
      !record.password
    ) {
      throw errorUtil.getInvalidArgumentError('register');
    }

    return AuthenticationModel.query().insert(record);
  },

  /**
   * Authenticates with an email and password
   *
   * @param {object} credentials
   */
  authenticate: (credentials) => {
    if (!credentials || !credentials.email || !credentials.password) {
      throw errorUtil.getInvalidArgumentError('authenticate');
    }

    return AuthenticationModel.query()
      .findOne(raw('LOWER(email)'), credentials.email.toLowerCase())
      .then((result) => {
        if (typeof result === 'undefined') {
          throw errorUtil.getAuthenticationError('no entry found');
        }

        if (!bcrypt.compareSync(credentials.password, result.password)) {
          throw errorUtil.getAuthenticationError('invalid password');
        }

        return jsonwebtoken.sign(
          {
            data: {
              authorityId: result.authority_id,
            },
          },
          process.env.JWT_SECRET,
          { expiresIn: process.env.JWT_EXPIRES_IN || '30d' }
        );
      });
  },

  /**
   * Provided a JWT token, this api returns who the authority is
   * and if it's still valid
   *
   * @param {string} token
   */
  verify: (token) => {
    if (!token) {
      throw errorUtil.getInvalidArgumentError('verify');
    }

    try {
      return jsonwebtoken.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      throw errorUtil.getInvalidTokenError(error.name + ': ' + error.message);
    }
  },

  /**
   * Deletes an authentication record from the database by the authorityId
   *
   * @param {number} authorityId
   *
   * @returns {Promise} Promise
   */
  deleteByAuthorityId: (authorityId) => {
    if (!authorityId) {
      throw errorUtil.getInvalidArgumentError('delete');
    }

    return AuthenticationModel.query()
      .where('authority_id', authorityId)
      .delete();
  },
};
