'use strict';

const objectionFiltersUtil = require.main.app('utils/filters');
const errorUtil = require.main.app('utils/errors');

/**
 * This service is the connection between the application and
 * the ORM.
 *
 * This class should be included for every model that requires REST
 *
 * All functions inside this class will return javascript promisses
 */
module.exports = (model) => ({
  /**
   * Fetches a list of records from the database
   *
   * @returns {Promise} Promise
   */
  query: (query) => {
    let queryBuilder = model.query();

    if (typeof query !== 'object') {
      return queryBuilder;
    }

    /* Select, Filter and Order */
    queryBuilder = objectionFiltersUtil.addSelect(queryBuilder, query.select);
    queryBuilder = objectionFiltersUtil.addFilter(queryBuilder, query.filter);
    queryBuilder = objectionFiltersUtil.addOrderBy(queryBuilder, query.order);
    queryBuilder = objectionFiltersUtil.addPagination(queryBuilder, query.page, query.pageSize);

    return queryBuilder;
  },

  /**
   * Fetches one record from the database
   *
   * @param {number} id
   *
   * @returns {Promise} Promise
   */
  show: (id) => {
    if (!id) {
      throw errorUtil.getInvalidArgumentError('show');
    }

    return model.query().findById(id);
  },

  /**
   * Creates a new record
   *
   * @param {object} record
   *
   * @returns {Promise} Promise
   */
  create: (record) => {
    if (!record) {
      throw errorUtil.getInvalidArgumentError('create');
    }

    return model.query().insert(record);
  },

  /**
   * Updates a record
   *
   * @param {number} id
   * @param {object} record
   *
   * @returns {Promise} Promise
   */
  update: (id, record) => {
    if (!id || !record) {
      throw errorUtil.getInvalidArgumentError('update');
    }

    return model.query().updateAndFetchById(id, record);
  },

  /**
   * Patches a record
   *
   * @param {number} id
   * @param {object} record
   *
   * @returns {Promise} Promise
   */
  patch: (id, record) => {
    if (!id || !record) {
      throw errorUtil.getInvalidArgumentError('patch');
    }

    return model.query().patchAndFetchById(id, record);
  },

  /**
   * Deletes a record from the database
   *
   * @param {number} id
   *
   * @returns {Promise} Promise
   */
  delete: (id) => {
    if (!id) {
      throw errorUtil.getInvalidArgumentError('delete');
    }

    return model.query().deleteById(id);
  },

  /**
   * Returns a count of records with the given key value pair list
   *
   * A `condition` key can be passed in the key/value list. The value of this key
   * needs to be '!=' and it will exclude this value from the search. Example use
   * would be if checking for unique email on update but we want to ignore the check
   * if the user never changed their email
   *
   * @returns {Promise} Promise
   */
  countBy: (keyValueList) => {
    if (typeof keyValueList === 'undefined') {
      throw errorUtil.getInvalidArgumentError('no argument found');
    }

    let query = model.query();

    if (!Array.isArray(keyValueList)) {
      throw errorUtil.getInvalidArgumentError('argument must be an array');
    }

    for (let index = 0; index < keyValueList.length; index++) {
      const whereClause = keyValueList[index];

      if (
        typeof whereClause !== 'object' ||
        typeof whereClause.key === 'undefined' ||
        typeof whereClause.value === 'undefined' ||
        (typeof whereClause.condition !== 'undefined' && whereClause.condition !== '!=')
      ) {
        throw errorUtil.getInvalidArgumentError('invalid object format');
      }

      if (typeof whereClause.condition !== 'undefined') {
        query = query.where(whereClause.key, '!=', whereClause.value);
      } else {
        query = query.where(whereClause.key, whereClause.value);
      }
    }

    return query.count();
  },
});
