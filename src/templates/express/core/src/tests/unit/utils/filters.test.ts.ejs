'use strict';

import chai from 'chai';

import filtersUtil from '../../../utils/filters';
import Model from '../../../resources/Model';

const expect = chai.expect;

describe('UNIT: filters util', () => {
  describe('addSelect', () => {
    it('it should return the query builder if the select is not defined', () => {
      let result = null;

      try {
        result = filtersUtil.addSelect(Model.query(), undefined);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(0);
    });

    it('it should add a select operation', () => {
      let result = null;

      try {
        result = filtersUtil.addSelect(Model.query(), 'id,column_two');
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('select');
      expect(result)
        .to.have.nested.property('_operations[0].args')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('column_two');
    });

    it('it should fail if the select is specified but is empty', () => {
      let result = null;

      try {
        result = filtersUtil.addSelect(Model.query(), '');
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('select');
    });

    it('it should fail if the select is specified but is null', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addSelect(Model.query(), null);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('select');
    });

    it('it should fail if the select is specified but is a number', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addSelect(Model.query(), 1);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('select');
    });

    it('it should fail if the select is specified but is an array', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addSelect(Model.query(), [1]);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('select');
    });

    it('it should fail if the select is specified but is an object', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addSelect(Model.query(), { test: 'test' });
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('select');
    });
  });

  describe('addFilter', () => {
    it('it should return the query builder if the filter is not defined', () => {
      let result = null;

      try {
        result = filtersUtil.addFilter(Model.query(), undefined);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(0);
    });

    it('it should fail if filter is not valid JSON', () => {
      let result = null;

      const filter = "[column:'id'}";

      try {
        result = filtersUtil.addFilter(Model.query(), filter);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter');
    });

    it('it should fail if filter is specified but is null', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addFilter(Model.query(), null);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter');
    });

    it('it should fail if filter is specified but is a number', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addFilter(Model.query(), 1);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter');
    });

    it('it should fail if filter is specified but is an array', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addFilter(Model.query(), [1]);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter');
    });

    it('it should fail if filter is specified but is an object', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addFilter(Model.query(), { test: 'test' });
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter');
    });

    it('it should fail if filter is not a json array', () => {
      let result = null;

      const filter = {
        column: 'id',
        value: 1,
      };

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter');
    });

    it('it should add filter operation as equals if filter is specified but no operator is passed', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should add filter operation using the gt operator', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          operator: 'gt',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('>');
      expect(result)
        .to.have.nested.property('_operations[0].args[2]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should add filter using the gte operator', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          operator: 'gte',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('>=');
      expect(result)
        .to.have.nested.property('_operations[0].args[2]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should add filter using the lt operator', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          operator: 'lt',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('<');
      expect(result)
        .to.have.nested.property('_operations[0].args[2]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should add filter using the lte operator', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          operator: 'lte',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('<=');
      expect(result)
        .to.have.nested.property('_operations[0].args[2]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should add filter using the ne operator', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          operator: 'ne',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('!=');
      expect(result)
        .to.have.nested.property('_operations[0].args[2]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should add filter using the eq operator', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          operator: 'eq',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('=');
      expect(result)
        .to.have.nested.property('_operations[0].args[2]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should add filter using the like operator', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          operator: 'like',
          value: 'my value',
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]._sql')
        .be.a('string')
        .and.equal('LOWER(id)');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('like');
      expect(result)
        .to.have.nested.property('_operations[0].args[2]')
        .be.a('string')
        .and.equal('my value');
    });

    it('it should fail if an invalid operator is specified', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          operator: 'invalid',
          value: 'my value',
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter[0].operator');
    });

    it('it should fail if attempting like on a non string column', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          operator: 'like',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter[0].value');
    });

    it('it should allow for multiple filters to be specified', () => {
      let result = null;

      const filter = [
        {
          column: 'column_one',
          value: 'my value',
        },
        {
          column: 'column_two',
          operator: 'like',
          value: 'myva%',
        },
        {
          column: 'id',
          operator: 'gte',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(3);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('column_one');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('my value');

      expect(result)
        .to.have.nested.property('_operations[1]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[1].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[1].args[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[1].args[0]._sql')
        .be.a('string')
        .and.equal('LOWER(column_two)');
      expect(result)
        .to.have.nested.property('_operations[1].args[1]')
        .be.a('string')
        .and.equal('like');
      expect(result)
        .to.have.nested.property('_operations[1].args[2]')
        .be.a('string')
        .and.equal('myva%');

      expect(result)
        .to.have.nested.property('_operations[2]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[2].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[2].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[2].args[1]')
        .be.a('string')
        .and.equal('>=');
      expect(result)
        .to.have.nested.property('_operations[2].args[2]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should fail if column is not specified', () => {
      let result = null;

      const filter = [
        {
          operator: 'eq',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter[0].column');
    });

    it('it should fail if value is not specified', () => {
      let result = null;

      const filter = [
        {
          column: 'column_one',
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter[0].value');
    });

    it('it should allow "and" condition', () => {
      let result = null;

      const filter = [
        {
          column: 'column_one',
          value: 'my value',
        },
        {
          condition: 'and',
          column: 'id',
          operator: 'eq',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('column_one');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('my value');

      expect(result)
        .to.have.nested.property('_operations[1]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[1].name')
        .be.a('string')
        .and.equal('andWhere');
      expect(result)
        .to.have.nested.property('_operations[1].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[1].args[1]')
        .be.a('string')
        .and.equal('=');
      expect(result)
        .to.have.nested.property('_operations[1].args[2]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should allow "and" condition with no operator', () => {
      let result = null;

      const filter = [
        {
          column: 'column_one',
          value: 'my value',
        },
        {
          condition: 'and',
          column: 'id',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('column_one');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('my value');

      expect(result)
        .to.have.nested.property('_operations[1]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[1].name')
        .be.a('string')
        .and.equal('andWhere');
      expect(result)
        .to.have.nested.property('_operations[1].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[1].args[1]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should allow "or" condition', () => {
      let result = null;

      const filter = [
        {
          column: 'column_one',
          value: 'my value',
        },
        {
          condition: 'or',
          column: 'id',
          operator: 'eq',
          value: 1,
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('column_one');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('my value');

      expect(result)
        .to.have.nested.property('_operations[1]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[1].name')
        .be.a('string')
        .and.equal('orWhere');
      expect(result)
        .to.have.nested.property('_operations[1].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[1].args[1]')
        .be.a('string')
        .and.equal('=');
      expect(result)
        .to.have.nested.property('_operations[1].args[2]')
        .be.a('number')
        .and.equal(1);
    });

    it('it should allow "in" condition', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          range: 'in',
          value: [1, 2, 3],
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('whereIn');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.an('array')
        .and.have.lengthOf(3);
      expect(result)
        .to.have.nested.property('_operations[0].args[1][0]')
        .be.a('number')
        .and.equal(1);
      expect(result)
        .to.have.nested.property('_operations[0].args[1][1]')
        .be.a('number')
        .and.equal(2);
      expect(result)
        .to.have.nested.property('_operations[0].args[1][2]')
        .be.a('number')
        .and.equal(3);
    });

    it('it should fail if value is not an array for "in"', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          range: 'in',
          value: { asd: 'something that is not an array' },
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('filter[0].value');
    });

    it('it should allow "orIn" condition', () => {
      let result = null;

      const filter = [
        {
          column: 'column_one',
          value: 'my value',
        },
        {
          column: 'id',
          range: 'orIn',
          value: [1, 2, 3],
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('column_one');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('my value');

      expect(result)
        .to.have.nested.property('_operations[1]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[1].name')
        .be.a('string')
        .and.equal('orWhereIn');
      expect(result)
        .to.have.nested.property('_operations[1].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[1].args[1]')
        .be.an('array')
        .and.have.lengthOf(3);
      expect(result)
        .to.have.nested.property('_operations[1].args[1][0]')
        .be.a('number')
        .and.equal(1);
      expect(result)
        .to.have.nested.property('_operations[1].args[1][1]')
        .be.a('number')
        .and.equal(2);
      expect(result)
        .to.have.nested.property('_operations[1].args[1][2]')
        .be.a('number')
        .and.equal(3);
    });

    it('it should allow "notIn" condition', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          range: 'notIn',
          value: [1, 2, 3],
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('whereNotIn');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.an('array')
        .and.have.lengthOf(3);
      expect(result)
        .to.have.nested.property('_operations[0].args[1][0]')
        .be.a('number')
        .and.equal(1);
      expect(result)
        .to.have.nested.property('_operations[0].args[1][1]')
        .be.a('number')
        .and.equal(2);
      expect(result)
        .to.have.nested.property('_operations[0].args[1][2]')
        .be.a('number')
        .and.equal(3);
    });

    it('it should allow "orNotIn" condition', () => {
      let result = null;

      const filter = [
        {
          column: 'column_one',
          value: 'my value',
        },
        {
          column: 'id',
          range: 'orNotIn',
          value: [1, 2, 3],
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('column_one');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('my value');

      expect(result)
        .to.have.nested.property('_operations[1]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[1].name')
        .be.a('string')
        .and.equal('orWhereNotIn');
      expect(result)
        .to.have.nested.property('_operations[1].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[1].args[1]')
        .be.an('array')
        .and.have.lengthOf(3);
      expect(result)
        .to.have.nested.property('_operations[1].args[1][0]')
        .be.a('number')
        .and.equal(1);
      expect(result)
        .to.have.nested.property('_operations[1].args[1][1]')
        .be.a('number')
        .and.equal(2);
      expect(result)
        .to.have.nested.property('_operations[1].args[1][2]')
        .be.a('number')
        .and.equal(3);
    });

    it('it should allow "between" condition', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          range: 'between',
          value: [1, 5],
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('whereBetween');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0].args[1][0]')
        .be.a('number')
        .and.equal(1);
      expect(result)
        .to.have.nested.property('_operations[0].args[1][1]')
        .be.a('number')
        .and.equal(5);
    });

    it('it should allow "orBetween" condition', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          value: 1,
        },
        {
          column: 'id',
          range: 'orBetween',
          value: [1, 5],
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('number')
        .and.equal(1);

      expect(result)
        .to.have.nested.property('_operations[1]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[1].name')
        .be.a('string')
        .and.equal('orWhereBetween');
      expect(result)
        .to.have.nested.property('_operations[1].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[1].args[1]')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[1].args[1][0]')
        .be.a('number')
        .and.equal(1);
      expect(result)
        .to.have.nested.property('_operations[1].args[1][1]')
        .be.a('number')
        .and.equal(5);
    });

    it('it should allow "notBetween" condition', () => {
      let result = null;

      const filter = [
        {
          column: 'id',
          range: 'notBetween',
          value: [1, 5],
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('whereNotBetween');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0].args[1][0]')
        .be.a('number')
        .and.equal(1);
      expect(result)
        .to.have.nested.property('_operations[0].args[1][1]')
        .be.a('number')
        .and.equal(5);
    });

    it('it should allow "orNotBetween" condition', () => {
      let result = null;

      const filter = [
        {
          column: 'column_one',
          value: 'my value',
        },
        {
          column: 'id',
          range: 'orNotBetween',
          value: [1, 5],
        },
      ];

      try {
        result = filtersUtil.addFilter(Model.query(), JSON.stringify(filter));
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('where');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('column_one');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('my value');

      expect(result)
        .to.have.nested.property('_operations[1]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[1].name')
        .be.a('string')
        .and.equal('orWhereNotBetween');
      expect(result)
        .to.have.nested.property('_operations[1].args[0]')
        .be.a('string')
        .and.equal('id');
      expect(result)
        .to.have.nested.property('_operations[1].args[1]')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[1].args[1][0]')
        .be.a('number')
        .and.equal(1);
      expect(result)
        .to.have.nested.property('_operations[1].args[1][1]')
        .be.a('number')
        .and.equal(5);
    });
  });

  describe('addOrderBy', () => {
    it('it should return the query builder if the order is not defined', () => {
      let result = null;

      try {
        result = filtersUtil.addOrderBy(Model.query(), undefined);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(0);
    });

    it('it should add ASC by default', () => {
      let result = null;

      try {
        result = filtersUtil.addOrderBy(Model.query(), 'column_one');
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('orderBy');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('column_one');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('ASC');
    });

    it('it should order the results in ASC if the order parameter is specified as ASC', () => {
      let result = null;

      try {
        result = filtersUtil.addOrderBy(Model.query(), 'column_one,ASC');
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('orderBy');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('column_one');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('ASC');
    });

    it('it should order the results in DESC if the order parameter is specified as DESC', () => {
      let result = null;

      try {
        result = filtersUtil.addOrderBy(Model.query(), 'column_one,DESC');
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].name')
        .be.a('string')
        .and.equal('orderBy');
      expect(result)
        .to.have.nested.property('_operations[0].args[0]')
        .be.a('string')
        .and.equal('column_one');
      expect(result)
        .to.have.nested.property('_operations[0].args[1]')
        .be.a('string')
        .and.equal('DESC');
    });

    it('it should fail if the order direction is not a valid value', () => {
      let result = null;

      try {
        result = filtersUtil.addOrderBy(Model.query(), 'column_one,UNKNOWN');
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('order');
    });

    it('it should fail if the order is specified but is empty', () => {
      let result = null;

      try {
        result = filtersUtil.addOrderBy(Model.query(), '');
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('order');
    });

    it('it should fail if the order is specified but is null', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addOrderBy(Model.query(), null);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('order');
    });

    it('it should fail if the order is specified but is a number', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addOrderBy(Model.query(), 1);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('order');
    });

    it('it should fail if the order is specified but is an array', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addOrderBy(Model.query(), [1]);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('order');
    });

    it('it should fail if the order is specified but is an object', () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addOrderBy(Model.query(), { test: 'test' });
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('order');
    });
  });

  describe('addPagination', () => {
    it('it should return the query builder if the page and pageSize are not defined', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addPagination(Model.query(), undefined, undefined);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(0);
    });

    it('it should paginate the operation if params are numbers', async () => {
      let result = null;

      try {
        result = filtersUtil.addPagination(Model.query(), 1, 50);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].childOperations')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[0].name')
        .be.an('string')
        .and.equal('limit');
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[0].args[0]')
        .be.a('number')
        .and.equal(50);
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[1].name')
        .be.an('string')
        .and.equal('offset');
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[1].args[0]')
        .be.a('number')
        .and.equal(0);
    });

    it('it should paginate the operation if params are strings', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addPagination(Model.query(), '1', '50');
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].childOperations')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[0].name')
        .be.an('string')
        .and.equal('limit');
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[0].args[0]')
        .be.a('number')
        .and.equal(50);
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[1].name')
        .be.an('string')
        .and.equal('offset');
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[1].args[0]')
        .be.a('number')
        .and.equal(0);
    });

    it('it should allow to get different pages', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addPagination(Model.query(), '5', '50');
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('object');
      expect(result)
        .to.have.property('_operations')
        .be.an('array')
        .and.have.lengthOf(1);
      expect(result)
        .to.have.nested.property('_operations[0]')
        .be.an('object');
      expect(result)
        .to.have.nested.property('_operations[0].childOperations')
        .be.an('array')
        .and.have.lengthOf(2);
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[0].name')
        .be.an('string')
        .and.equal('limit');
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[0].args[0]')
        .be.a('number')
        .and.equal(50);
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[1].name')
        .be.an('string')
        .and.equal('offset');
      expect(result)
        .to.have.nested.property('_operations[0].childOperations[1].args[0]')
        .be.a('number')
        .and.equal(200);
    });

    it('it should fail if page is defined but pageSize is not', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addPagination(Model.query(), 1, undefined);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('pagination');
    });

    it('it should fail if page or pageSize are specified but are null', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addPagination(Model.query(), null, null);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('pagination');
    });

    it('it should fail if page or pageSize are specified but are arrays', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addPagination(Model.query(), [1], [1]);
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('pagination');
    });

    it('it should fail if page or pageSize are specified but are objects', async () => {
      let result = null;

      try {
        // @ts-ignore
        result = filtersUtil.addPagination(Model.query(), { test: 'test' }, { test: 'test' });
      } catch (error) {
        result = error;
      }

      expect(result).to.be.an('error');
      expect(result)
        .to.have.property('type')
        .equal('InvalidArgumentError');
      expect(result)
        .to.have.property('status')
        .equal(400);
      expect(result)
        .to.have.property('error')
        .equal('pagination');
    });
  });
});
